## От стимула к смыслу: шаги **B → C → D → E** (пример цифры **1**)

Ниже — как один образ (цифра **1**) проходит через конвейер и что показывают панели B–E в `visualize_pipeline`.

---

### Подготовка (однократно)
- **Кодбуки (codebooks)** в `PrimaryEncoder`: детерминированные таблицы сопоставления «признак → набор битов» в пространстве `0..B-1` (у нас `B=8192`).
- **Раскладка** `Layout2D`: обучающие коды разложены по решётке `H×W` (например, 90×90).
- **Детекторы** `DetectorSpace`: из «пинвилов» на раскладке собраны области (круги/эллипсы), каждой области назначен **один бит** в пространстве эмбеддинга `0..E-1` (например, `E=256`). Важные параметры: `percentile=0.88`, `lam_floor=0.06`, `mu=0.20`, `min_activated=35`.

---

## B) Первичный код (штрихкод из `0..8191`)
Функция `enc.encode(img)` превращает картинку **28×28** (в [0,1]) в **разрежённый набор битов** через несколько каналов (каждый канал добавляет свои биты из кодбука):

1. **BRIGHT** *(приоритет 0.0)*  
   Средняя яркость кадра квантуется (на 8 уровней) → включаем 4 бита из `bright_codebook`.

2. **COARSE 2×2** *(приоритет 1.0)*  
   Для каждой четверти, если средняя яркость > 0.15, добавляем её биты (по 4).

3. **ORIENT 4×4 (Sobel)** *(приоритет 1.5)*  
   Считаем градиенты (величина/угол). В каждом из 16 тайлов берём доминантный угол (из 8 бинов), если средняя величина ≥ 0.12 → добавляем по 2 бита.  
   Для «1» доминирует **вертикальная** ориентация в тайлах, пересечённых штрихом.

4. **GRID 4×4** *(приоритет 2.0)*  
   В каждом тайле берём среднюю яркость, квантуем на 4 уровня и добавляем по 3 бита для уровня (и соседнего `lvl-1` для лёгкого перекрытия).

5. **Сведение («цветовое» объединение)**  
   Все пары *(priority, bit)* сортируются и отфильтровываются по лимиту `max_active_bits` (например, 260).  
   На панели **B** это изображается как «штрихкод» индексов активных битов.

**Что характерно для «1»**: низкий BRIGHT, слабые COARSE (если штрих тонкий), сильные вертикальные ORIENT в 2–5 тайлах, GRID подчёркивает конкретные позиции штриха.

---

## C) Карта активации на раскладке (где похожие обучающие)
Функция `det._activation_map_adaptive(code)`:

1. Для **каждой занятой клетки** `(y,x)` раскладки берём код обучающего примера и считаем схожесть с текущим `code` по `cosbin` (|пересечение| / √(размеров)).
2. Получаем матрицу `sims[y,x]` и порог:
```
thr = max(lam_floor, quantile(sims, percentile))  # напр. max(0.06, 88-й перцентиль)
```
3. Делаем булеву карту `act = sims >= thr`. Если активных клеток слишком мало, добираем **top-35** по `sims`.

Для «1» вспыхивает кластер в области, где на раскладке «живут» обучающие единицы. Соседние классы с похожими штрихами могут давать слабые «островки».

---

## D) Сработавшие детекторы (контуры на карте)
Функция `det.embed(code)` решает, какие детекторы «стреляют»:

1. У каждого детектора есть **область** (круг или **PCA-эллипс**) и **бит** эмбеддинга.
2. Считаем долю клеток с `act=True` **внутри области**. Если доля ≥ `mu` (напр. 0.20), детектор считается сработавшим.
3. На панели **D** рисуются контуры сработавших областей поверх карты **C**.

Для «1» охотно срабатывают **вертикально вытянутые** эллипсы в «ядре» кластера единиц.

---

## E) Эмбеддинг (штрихкод из `0..E-1`)
Результат `det.embed(code)` — множество индексов **сработавших детекторов** (из `0..E-1`), которое мы показываем как штрихкод:

- Обычно активируется **несколько десятков** битов (зависит от числа детекторов и порога `mu`).
- Именно этот набор идёт в kNN по Жаккару.

Для «1» в эмбеддинг попадают биты, соответствующие вертикальным и «кластерным» детекторам вокруг региона единиц.

---

### Сводка потока сигнала
- **B:** признаки → через кодбуки → первичный разрежённый код (`0..B-1`).  
- **C:** сравнение с обучающими на раскладке → порог по перцентилю → карта «где похоже».  
- **D:** проверяем области детекторов на достаточную долю совпадений → «выстрелившие» контуры.  
- **E:** индексы сработавших детекторов → финальный эмбеддинг (`0..E-1`), который идёт в классификатор (kNN по Жаккару).

---

## Соответствие статье и отличия реализации

---

### ✅ Что соответствует статье (по духу и целям)
- **Разрежённые бинарные коды** и «цветовое» объединение признаков в единый первичный код.
- **Два масштаба организации** (дальний/ближний порядок) и раскладка «похожие ближе».
- **Энергия вида** `sim × dist` и **локальные свапы** при раскладке (DAMP-подход).
- **Детекторы как геометрические поля** (круги/эллипсы), каждый даёт **1 бит** эмбеддинга.
- **Метрики схожести для битовых кодов** (Жаккар/“дискретный косинус”).
- **Эллипсы через PCA** — допустимый усиленный вариант для вытянутых кластеров (мы включили по умолчанию).

---

### ⚠️ Где упростили или отошли от канона
1. **«Цветовое» объединение**: вместо формальной процедуры через функцию `f` и спектры — простой **top-K по приоритетам**.
2. **Цели фаз DAMP**: в статье дальняя и ближняя фазы оптимизируют **разные** цели (дальняя — глобальная минимизация, ближняя — локальная «полировка» с иным знаком/смыслом). У нас обе фазы фактически **минимизируют одну и ту же локальную энергию**.
3. **Глобальность дальней энергии**: в каноне дальняя фаза действительно «глобальная». У нас — **локализованный радиус** (приближение).
4. **Пороговая близость `sim_λ`**: в статье ключевой элемент — **порогованная** близость с фиксированным `λ`. У нас — **адаптивный перцентиль** по полю похожестей (λ нет).
5. **Иерархия уровней у детекторов**: в статье **фиксируют λ на уровне** и строят детекторы **этапами**. У нас λ не фиксируется по уровням — фактически **подстраивается под семя/пример**.
6. **Кластеризация «пинвилов»**: рекомендован **DBSCAN**; у нас — **связные компоненты** по решётке (упрощение).
7. **Правило вставки детекторов**: в статье — запрет перекрытия центров/замещение по коэффициенту **`n/r`**. У нас — **только минимум расстояния** между центрами и сортировка по «силе».
8. **Критерий срабатывания детектора**: формально используют **нормализованную энергию внутри поля**; у нас — **доля активных клеток** (покрытие по булевой карте).
9. **Коды для углов (замкнутая топология)**: статья акцентирует «замыкание» (цилиндр/тор, Gray). У нас — **простой биннинг Sobel** без явного замкнутого кодирования.
10. **Диагностика раскладки**: в каноне считают/логируют **\hat{E}** и **\bar{E}** (карта и средняя энергия). У нас это **не выводится**.

---

### 🛠️ Что добавили как инженерные решения (вне текста)
- Канал **ORIENT (Sobel)** + приоритеты каналов и перекрытие уровней GRID.
- **Перцентильная активация** детекторов с «страховкой» top-N.
- **Эллипсы по PCA** включены «из коробки» для вытянутых областей.
- **Взвешенный kNN по Жаккару** поверх эмбеддинга (в статье это не основной объект).
- Утилиты визуализации (`visualize_pipeline`, PDF-экспорты) и суммарные карты наложений.

